<?php

namespace AppBundle\Entity;

use Doctrine\ORM\EntityRepository;

/**
 * MeasurementTimeSeriesRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class MeasurementTimeSeriesRepository extends EntityRepository
{
    const NOT_A_TEMPERATURE = 999.9;

    /**
     * Returns a matching time series for the given probe and time, if it exists.
     *
     * @param MeasurementProbe $measurementProbe
     * @param \DateTime $date
     * @return null|object
     */
    public function getTimeSeries(MeasurementProbe $measurementProbe, \DateTime $date)
    {
        $date = $this->truncateSeconds($date);

        return $this->findOneBy([
            'measurementProbe' => $measurementProbe,
            'time' => $date,
        ]);
    }

    /**
     * Creates a time series for the given probe and time.
     *
     * @param MeasurementProbe $measurementProbe
     * @param \DateTime $date
     * @return MeasurementTimeSeries
     */
    public function createTimeSeries(MeasurementProbe $measurementProbe, \DateTime $date)
    {
        $date = $this->truncateSeconds($date);

        $series = new MeasurementTimeSeries();
        $series->setMeasurementProbe($measurementProbe);
        $series->setTime($date);

        $em = $this->getEntityManager();
        $em->persist($series);
        $em->flush();

        return $series;
    }

    /**
     * Truncates the seconds of the given date.
     *
     * @param \DateTime $date
     * @return \DateTime
     */
    protected function truncateSeconds(\DateTime $date)
    {
        $ts = $date->getTimestamp() - ($date->getTimestamp() % 60);

        $newDate = new \DateTime();
        $newDate->setTimestamp($ts);

        return $newDate;
    }

    /**
     * Returns the last recorded measurement.
     *
     * @param Measurement $measurement
     * @return \DateTime|null
     */
    public function getLastMeasurement(Measurement $measurement)
    {
        $last = null;

        /** @var MeasurementProbe $probe */
        foreach ($measurement->getProbes() as $probe) {
            $timeSeries = $this->findOneBy(
                ['measurementProbe' => $probe],
                ['time' => 'DESC']
            );

            if ($timeSeries) {
                $tmp = $timeSeries->getCurrentValuesTime();
                $last = (!$last || $last < $tmp) ? $tmp : $last;
            }
        }

        return $last;
    }

    /**
     * Returns the current values for the measurements probes.
     *
     * @param Measurement $measurement
     * @return array
     */
    public function getCurrentValues(Measurement $measurement)
    {
        $current = [];

        /** @var MeasurementProbe $probe */
        foreach ($measurement->getProbes() as $probe) {
            $timeSeries = $this->findOneBy(
                ['measurementProbe' => $probe],
                ['time' => 'DESC']
            );

            $current[$probe->getId()] = $timeSeries ?
                $timeSeries->getCurrentValue() : self::NOT_A_TEMPERATURE;
        }

        return $current;
    }

    /**
     * Returns the full time series history for the given measurement.
     *
     * @param Measurement $measurement
     * @return array
     */
    public function getFullHistory(Measurement $measurement)
    {
        $history = [];

        /** @var MeasurementProbe $probe */
        foreach ($measurement->getProbes() as $probe) {
            $entities = $this->findBy(
                ['measurementProbe' => $probe],
                ['time' => 'DESC']
            );

            $history[$probe->getId()] = $entities;
        }

        return $history;
    }
}
